<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sander Buruma - Software Developer</title>
    <link rel="stylesheet" href="styles.css">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body>
    <div id="root"></div>
    
    <script type="text/babel">
        const { useState, useEffect, useRef, useContext, createContext, useReducer } = React;
        
        // Theme Context
        const ThemeContext = createContext();
        
        // Custom hook for theme
        const useTheme = () => {
            const context = useContext(ThemeContext);
            if (!context) {
                throw new Error('useTheme must be used within ThemeProvider');
            }
            return context;
        };
        
        // Theme reducer
        const themeReducer = (state, action) => {
            switch (action.type) {
                case 'TOGGLE_THEME':
                    return { ...state, isDark: !state.isDark };
                case 'SET_THEME':
                    return { ...state, isDark: action.payload };
                default:
                    return state;
            }
        };
        
        // Theme Provider
        const ThemeProvider = ({ children }) => {
            const [state, dispatch] = useReducer(themeReducer, { 
                isDark: localStorage.getItem('theme') === 'dark' 
            });
            
            useEffect(() => {
                document.documentElement.setAttribute('data-theme', state.isDark ? 'dark' : 'light');
                localStorage.setItem('theme', state.isDark ? 'dark' : 'light');
            }, [state.isDark]);
            
            return React.createElement(ThemeContext.Provider, {
                value: { ...state, dispatch }
            }, children);
        };
        
        // Custom hook for counter animation
        const useCountUp = (end, duration = 2000) => {
            const [count, setCount] = useState(0);
            const [isVisible, setIsVisible] = useState(false);
            const ref = useRef();
            
            useEffect(() => {
                const observer = new IntersectionObserver(
                    ([entry]) => {
                        if (entry.isIntersecting && !isVisible) {
                            setIsVisible(true);
                        }
                    },
                    { threshold: 0.1 }
                );
                
                if (ref.current) {
                    observer.observe(ref.current);
                }
                
                return () => observer.disconnect();
            }, [isVisible]);
            
            useEffect(() => {
                if (isVisible) {
                    let startTime;
                    const animate = (timestamp) => {
                        if (!startTime) startTime = timestamp;
                        const progress = Math.min((timestamp - startTime) / duration, 1);
                        setCount(Math.floor(progress * end));
                        
                        if (progress < 1) {
                            requestAnimationFrame(animate);
                        }
                    };
                    requestAnimationFrame(animate);
                }
            }, [isVisible, end, duration]);
            
            return [count, ref];
        };
        
        const Navbar = () => {
            const [mobileMenuOpen, setMobileMenuOpen] = useState(false);
            const [scrolled, setScrolled] = useState(false);
            const { isDark, dispatch } = useTheme();
            
            useEffect(() => {
                const handleScroll = () => {
                    setScrolled(window.scrollY > 100);
                };
                
                window.addEventListener('scroll', handleScroll);
                return () => window.removeEventListener('scroll', handleScroll);
            }, []);
            
            const navStyle = {
                background: isDark 
                    ? (scrolled ? 'rgba(15, 23, 42, 0.98)' : 'rgba(15, 23, 42, 0.95)')
                    : (scrolled ? 'rgba(255, 255, 255, 0.98)' : 'rgba(255, 255, 255, 0.95)'),
                backdropFilter: scrolled ? 'blur(20px)' : 'blur(10px)'
            };
            
            return React.createElement('nav', {
                className: 'navbar',
                style: navStyle
            },
                React.createElement('div', { className: 'nav-container' },
                    React.createElement('div', { className: 'nav-logo' },
                        React.createElement('h2', null, 'Sander Buruma')
                    ),
                    React.createElement('ul', {
                        className: `nav-menu ${mobileMenuOpen ? 'active' : ''}`
                    },
                        ['Home', 'About', 'Experience', 'Projects', 'Minesweeper', 'Contact'].map(item =>
                            React.createElement('li', { key: item, className: 'nav-item' },
                                React.createElement('a', {
                                    href: `#${item.toLowerCase()}`,
                                    className: 'nav-link',
                                    onClick: () => setMobileMenuOpen(false)
                                }, item)
                            )
                        )
                    ),
                    React.createElement('div', {
                        className: `nav-toggle ${mobileMenuOpen ? 'active' : ''}`,
                        onClick: () => setMobileMenuOpen(!mobileMenuOpen)
                    },
                        React.createElement('span', { className: 'bar' }),
                        React.createElement('span', { className: 'bar' }),
                        React.createElement('span', { className: 'bar' })
                    ),
                    React.createElement('button', {
                        className: 'theme-toggle',
                        onClick: () => dispatch({ type: 'TOGGLE_THEME' }),
                        'aria-label': 'Toggle theme'
                    },
                        React.createElement('i', { 
                            className: isDark ? 'fas fa-sun' : 'fas fa-moon' 
                        })
                    )
                )
            );
        };
        
        const HeroSection = () => {
            const [titleText, setTitleText] = useState('');
            const fullTitle = "Hi, I'm <span class=\"gradient-text\">Sander Buruma</span>";
            
            useEffect(() => {
                let index = 0;
                const timer = setTimeout(() => {
                    const typeWriter = () => {
                        if (index < fullTitle.length) {
                            setTitleText(fullTitle.slice(0, index + 1));
                            index++;
                            setTimeout(typeWriter, 50);
                        }
                    };
                    typeWriter();
                }, 500);
                
                return () => clearTimeout(timer);
            }, []);
            
            return React.createElement('section', { id: 'home', className: 'hero' },
                React.createElement('div', { className: 'hero-container' },
                    React.createElement('div', { className: 'hero-content' },
                        React.createElement('h1', {
                            className: 'hero-title',
                            dangerouslySetInnerHTML: { __html: titleText }
                        }),
                        React.createElement('h2', { className: 'hero-subtitle' }, 'Software Developer'),
                        React.createElement('p', { className: 'hero-description' },
                            'I create efficient, scalable solutions with a focus on blockchain technology, web development, and data analysis. Passionate about turning complex problems into elegant code.'
                        ),
                        React.createElement('div', { className: 'hero-buttons' },
                            React.createElement('a', {
                                href: '#projects',
                                className: 'btn btn-primary'
                            }, 'View My Work'),
                            React.createElement('a', {
                                href: '#contact',
                                className: 'btn btn-secondary'
                            }, 'Get In Touch')
                        )
                    ),
                    React.createElement('div', { className: 'hero-image' },
                        React.createElement('div', { className: 'floating-card' },
                            React.createElement('i', { className: 'fas fa-code' })
                        )
                    )
                )
            );
        };
        
        const StatCard = ({ value, label, suffix = '' }) => {
            const [count, ref] = useCountUp(value);
            
            return React.createElement('div', { className: 'stat', ref },
                React.createElement('h3', null, `${count}${suffix}`),
                React.createElement('p', null, label)
            );
        };
        
        const AboutSection = () => {
            // Calculate years of experience from February 2020 to now, rounded up
            const startDate = new Date(2020, 1); // February 2020 (month is 0-indexed)
            const now = new Date();
            const yearsDiff = (now - startDate) / (1000 * 60 * 60 * 24 * 365.25);
            const yearsExperience = Math.ceil(yearsDiff);

            return React.createElement('section', { id: 'about', className: 'about' },
                React.createElement('div', { className: 'container' },
                    React.createElement('h2', { className: 'section-title' }, 'About Me'),
                    React.createElement('div', { className: 'about-content' },
                        React.createElement('div', { className: 'about-text' },
                            React.createElement('p', null,
                                "I'm a software developer with a passion for creating innovative solutions in blockchain technology, web development, and data analysis. With experience in multiple programming languages and frameworks, I enjoy tackling complex challenges and building applications that make a difference."
                            ),
                            React.createElement('p', null,
                                'My expertise spans from backend development with Python and JavaScript to blockchain analysis and cryptocurrency trading tools. I believe in writing clean, maintainable code and staying up-to-date with the latest technologies.'
                            )
                        ),
                        React.createElement('div', { className: 'about-stats' },
                            React.createElement(StatCard, {
                                value: yearsExperience,
                                label: 'Years Experience',
                                suffix: '+'
                            }),
                            React.createElement(StatCard, {
                                value: 50,
                                label: 'Projects Completed',
                                suffix: '+'
                            }),
                            React.createElement(StatCard, {
                                value: 10,
                                label: 'Technologies',
                                suffix: '+'
                            })
                        )
                    )
                )
            );
        };
        
        const ExperienceSection = () => {
            const experiences = [
                {
                    title: 'Python Developer',
                    company: 'CitizenGO',
                    location: 'Remote',
                    period: 'Nov 2022 - Present',
                    description: [
                        'Developed Python Selenium end-to-end test environment for donation pipeline',
                        'Implemented SQL monitoring of donation pipeline acceptance ratio and fraud detection',
                        'Built AI project with Python Django for employee productivity reporting to management'
                    ]
                },
                {
                    title: 'Dotnet Developer',
                    company: 'AWI bv',
                    location: 'Netherlands',
                    period: 'May 2022 - Nov 2022',
                    description: [
                        'Fixed bugs in decades-old C# legacy codebase with millions of lines of code',
                        'Performed general refactoring and code improvements'
                    ]
                },
                {
                    title: 'Python Developer | Database Admin | Data Analyst',
                    company: 'Civitas Christiana',
                    location: 'Veenendaal',
                    period: 'Feb 2021 - May 2022',
                    description: [
                        'Automated donation data input, saving 20 hours per week',
                        'Implemented auto-correction of erroneous user input using Python',
                        'Extracted data from legacy website using Python Selenium',
                        'Implemented postcode checker in PHP, eliminating address errors',
                        'Provided general IT support'
                    ]
                },
                {
                    title: 'Dotnet Developer',
                    company: 'HRorganizer',
                    location: 'Wageningen',
                    period: 'Jan 2020 - Feb 2021',
                    description: [
                        'Converted 100,000+ lines of .NET code from synchronous to asynchronous',
                        'Achieved 20% latency improvement',
                        'Built personalization test in Angular (TypeScript) now in production use'
                    ]
                }
            ];

            return React.createElement('section', { id: 'experience', className: 'experience' },
                React.createElement('div', { className: 'container' },
                    React.createElement('h2', { className: 'section-title' }, 'Work Experience'),
                    React.createElement('div', { className: 'experience-timeline' },
                        experiences.map((exp, index) =>
                            React.createElement('div', {
                                key: index,
                                className: 'experience-item'
                            },
                                React.createElement('div', { className: 'experience-content' },
                                    React.createElement('div', { className: 'experience-header' },
                                        React.createElement('div', null,
                                            React.createElement('h3', null, exp.title),
                                            React.createElement('h4', null, exp.company),
                                            React.createElement('p', { className: 'experience-meta' },
                                                React.createElement('i', { className: 'fas fa-map-marker-alt' }),
                                                ` ${exp.location} | `,
                                                React.createElement('i', { className: 'fas fa-calendar' }),
                                                ` ${exp.period}`
                                            )
                                        )
                                    ),
                                    React.createElement('ul', { className: 'experience-description' },
                                        exp.description.map((item, i) =>
                                            React.createElement('li', { key: i }, item)
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            );
        };

        const ProjectsSection = () => {
            const [filter, setFilter] = useState('all');
            const [searchTerm, setSearchTerm] = useState('');
            
            const projects = [
                {
                    title: 'Solana Chain Analyzer',
                    icon: 'fas fa-chart-line',
                    description: 'Comprehensive cryptocurrency analysis tool that processes Solana blockchain data to identify trading patterns, volatility, and market trends.',
                    tags: ['Python', 'Blockchain', 'Data Analysis'],
                    category: 'blockchain'
                },
                {
                    title: 'Telegram Trading Bot',
                    icon: 'fas fa-robot',
                    description: 'Automated trading signal analyzer that evaluates crypto trading channels and provides performance metrics and success rates.',
                    tags: ['Python', 'Telegram API', 'Django'],
                    category: 'automation'
                },
                {
                    title: 'Blockchain Wallet Inspector',
                    icon: 'fas fa-wallet',
                    description: 'Web3 tool for inspecting Solana wallets, displaying token balances, and transaction history with a clean, user-friendly interface.',
                    tags: ['Web3', 'Solana', 'React'],
                    category: 'blockchain'
                },
                {
                    title: 'Portfolio Website',
                    icon: 'fas fa-globe',
                    description: 'Modern React-based portfolio website with interactive components, theme switching, and smooth animations.',
                    tags: ['React', 'JavaScript', 'CSS'],
                    category: 'web'
                },
                {
                    title: 'API Rate Limiter',
                    icon: 'fas fa-shield-alt',
                    description: 'High-performance rate limiting service built with Redis and Node.js for API protection and traffic management.',
                    tags: ['Node.js', 'Redis', 'Docker'],
                    category: 'backend'
                }
            ];
            
            const filteredProjects = projects.filter(project => {
                const matchesFilter = filter === 'all' || project.category === filter;
                const matchesSearch = project.title.toLowerCase().includes(searchTerm.toLowerCase()) ||
                                    project.description.toLowerCase().includes(searchTerm.toLowerCase()) ||
                                    project.tags.some(tag => tag.toLowerCase().includes(searchTerm.toLowerCase()));
                return matchesFilter && matchesSearch;
            });
            
            const categories = ['all', ...new Set(projects.map(p => p.category))];
            
            return React.createElement('section', { id: 'projects', className: 'projects' },
                React.createElement('div', { className: 'container' },
                    React.createElement('h2', { className: 'section-title' }, 'Featured Projects'),
                    React.createElement('div', { className: 'projects-filters' },
                        React.createElement('input', {
                            type: 'text',
                            placeholder: 'Search projects...',
                            value: searchTerm,
                            onChange: (e) => setSearchTerm(e.target.value),
                            className: 'project-search'
                        }),
                        React.createElement('div', { className: 'filter-buttons' },
                            categories.map(category =>
                                React.createElement('button', {
                                    key: category,
                                    className: `filter-btn ${filter === category ? 'active' : ''}`,
                                    onClick: () => setFilter(category)
                                }, category.charAt(0).toUpperCase() + category.slice(1))
                            )
                        )
                    ),
                    React.createElement('div', { className: 'projects-grid' },
                        filteredProjects.map(project => 
                            React.createElement('div', {
                                key: project.title,
                                className: 'project-card'
                            },
                                React.createElement('div', { className: 'project-image' },
                                    React.createElement('i', { className: project.icon })
                                ),
                                React.createElement('div', { className: 'project-content' },
                                    React.createElement('h3', null, project.title),
                                    React.createElement('p', null, project.description),
                                    React.createElement('div', { className: 'project-tags' },
                                        project.tags.map(tag => 
                                            React.createElement('span', { key: tag }, tag)
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            );
        };
        
        const ContactSection = () => {
            const [formData, setFormData] = useState({
                name: '',
                email: '',
                message: ''
            });
            const [isSubmitting, setIsSubmitting] = useState(false);
            
            const handleSubmit = (e) => {
                e.preventDefault();
                
                if (!formData.name || !formData.email || !formData.message) {
                    alert('Please fill in all fields');
                    return;
                }
                
                const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
                if (!emailRegex.test(formData.email)) {
                    alert('Please enter a valid email address');
                    return;
                }
                
                setIsSubmitting(true);
                
                setTimeout(() => {
                    alert('Thank you for your message! I\'ll get back to you soon.');
                    setFormData({ name: '', email: '', message: '' });
                    setIsSubmitting(false);
                }, 1500);
            };
            
            const handleChange = (e) => {
                setFormData({
                    ...formData,
                    [e.target.name]: e.target.value
                });
            };
            
            return React.createElement('section', { id: 'contact', className: 'contact' },
                React.createElement('div', { className: 'container' },
                    React.createElement('h2', { className: 'section-title' }, 'Get In Touch'),
                    React.createElement('div', { className: 'contact-content' },
                        React.createElement('div', { className: 'contact-info' },
                            React.createElement('h3', null, 'Let\'s work together'),
                            React.createElement('p', null,
                                'I\'m always interested in new opportunities and exciting projects. Whether you have a question or just want to say hi, feel free to reach out!'
                            ),
                            React.createElement('div', { className: 'contact-items' },
                                React.createElement('div', { className: 'contact-item' },
                                    React.createElement('i', { className: 'fas fa-envelope' }),
                                    React.createElement('a', {
                                        href: 'mailto:info@sanderburuma.nl'
                                    }, 'info@sanderburuma.nl')
                                ),
                                React.createElement('div', { className: 'contact-item' },
                                    React.createElement('i', { className: 'fab fa-github' }),
                                    React.createElement('a', {
                                        href: 'https://github.com/sanderburuma',
                                        target: '_blank',
                                        rel: 'noopener'
                                    }, 'github.com/sanderburuma')
                                ),
                                React.createElement('div', { className: 'contact-item' },
                                    React.createElement('i', { className: 'fab fa-linkedin' }),
                                    React.createElement('a', {
                                        href: 'https://www.linkedin.com/in/sander-buruma-729a84235',
                                        target: '_blank',
                                        rel: 'noopener'
                                    }, 'linkedin.com/in/sander-buruma')
                                )
                            )
                        ),
                        React.createElement('form', {
                            className: 'contact-form',
                            onSubmit: handleSubmit
                        },
                            React.createElement('div', { className: 'form-group' },
                                React.createElement('input', {
                                    type: 'text',
                                    name: 'name',
                                    placeholder: 'Your Name',
                                    required: true,
                                    value: formData.name,
                                    onChange: handleChange
                                })
                            ),
                            React.createElement('div', { className: 'form-group' },
                                React.createElement('input', {
                                    type: 'email',
                                    name: 'email',
                                    placeholder: 'Your Email',
                                    required: true,
                                    value: formData.email,
                                    onChange: handleChange
                                })
                            ),
                            React.createElement('div', { className: 'form-group' },
                                React.createElement('textarea', {
                                    name: 'message',
                                    rows: 5,
                                    placeholder: 'Your Message',
                                    required: true,
                                    value: formData.message,
                                    onChange: handleChange
                                })
                            ),
                            React.createElement('button', {
                                type: 'submit',
                                className: 'btn btn-primary',
                                disabled: isSubmitting
                            }, isSubmitting ? 'Sending...' : 'Send Message')
                        )
                    )
                )
            );
        };
        
        const Footer = () => {
            return React.createElement('footer', { className: 'footer' },
                React.createElement('div', { className: 'container' },
                    React.createElement('div', { className: 'footer-content' },
                        React.createElement('p', null, 'Â© 2025 Sander Buruma. All rights reserved.'),
                        React.createElement('div', { className: 'social-links' },
                            React.createElement('a', {
                                href: 'https://github.com/sanderburuma',
                                target: '_blank',
                                rel: 'noopener',
                                className: 'social-link'
                            },
                                React.createElement('i', { className: 'fab fa-github' })
                            ),
                            React.createElement('a', {
                                href: 'https://www.linkedin.com/in/sander-buruma-729a84235',
                                target: '_blank',
                                rel: 'noopener',
                                className: 'social-link'
                            },
                                React.createElement('i', { className: 'fab fa-linkedin' })
                            )
                        )
                    )
                )
            );
        };
        
        const Minesweeper4D = () => {
            const [board, setBoard] = useState([]);
            const [gameOver, setGameOver] = useState(false);
            const [win, setWin] = useState(false);
            const [hoveredCell, setHoveredCell] = useState(null);
            const [dragStart, setDragStart] = useState(null);
            const [dragCurrent, setDragCurrent] = useState(null);
            const [isDragging, setIsDragging] = useState(false);
            const justDraggedRef = useRef(false);

            const SIZE = 4;
            const MINES = 20;

            useEffect(() => {
                setBoard(createBoard());
            }, []);

            useEffect(() => {
                const handleGlobalMouseUp = () => {
                    if (isDragging) {
                        setDragStart(null);
                        setDragCurrent(null);
                        setIsDragging(false);
                    }
                };

                document.addEventListener('mouseup', handleGlobalMouseUp);
                return () => {
                    document.removeEventListener('mouseup', handleGlobalMouseUp);
                };
            }, [isDragging]);

            const createBoard = () => {
                let newBoard = Array(SIZE).fill(0).map(() =>
                    Array(SIZE).fill(0).map(() =>
                        Array(SIZE).fill(0).map(() =>
                            Array(SIZE).fill(0).map(() => ({
                                isMine: false,
                                isRevealed: false,
                                isFlagged: false,
                                adjacentMines: 0
                            }))
                        )
                    )
                );

                let minesPlaced = 0;
                while (minesPlaced < MINES) {
                    const x = Math.floor(Math.random() * SIZE);
                    const y = Math.floor(Math.random() * SIZE);
                    const z = Math.floor(Math.random() * SIZE);
                    const w = Math.floor(Math.random() * SIZE);

                    if (!newBoard[w][z][y][x].isMine) {
                        newBoard[w][z][y][x].isMine = true;
                        minesPlaced++;
                    }
                }

                for (let w = 0; w < SIZE; w++) {
                    for (let z = 0; z < SIZE; z++) {
                        for (let y = 0; y < SIZE; y++) {
                            for (let x = 0; x < SIZE; x++) {
                                if (!newBoard[w][z][y][x].isMine) {
                                    newBoard[w][z][y][x].adjacentMines = countAdjacentMines(newBoard, x, y, z, w);
                                }
                            }
                        }
                    }
                }
                return newBoard;
            };

            const countAdjacentMines = (board, x, y, z, w) => {
                let count = 0;
                for (let dw = -1; dw <= 1; dw++) {
                    for (let dz = -1; dz <= 1; dz++) {
                        for (let dy = -1; dy <= 1; dy++) {
                            for (let dx = -1; dx <= 1; dx++) {
                                if (dw === 0 && dz === 0 && dy === 0 && dx === 0) continue;

                                const nw = w + dw;
                                const nz = z + dz;
                                const ny = y + dy;
                                const nx = x + dx;

                                if (nw >= 0 && nw < SIZE && nz >= 0 && nz < SIZE && ny >= 0 && ny < SIZE && nx >= 0 && nx < SIZE) {
                                    if (board[nw][nz][ny][nx].isMine) {
                                        count++;
                                    }
                                }
                            }
                        }
                    }
                }
                return count;
            };

            const isAdjacent = (x1, y1, z1, w1, x2, y2, z2, w2) => {
                if (x1 === x2 && y1 === y2 && z1 === z2 && w1 === w2) return false;
                const dx = Math.abs(x1 - x2);
                const dy = Math.abs(y1 - y2);
                const dz = Math.abs(z1 - z2);
                const dw = Math.abs(w1 - w2);
                return dx <= 1 && dy <= 1 && dz <= 1 && dw <= 1;
            };

            const countAdjacentFlags = (board, x, y, z, w) => {
                let count = 0;
                for (let dw = -1; dw <= 1; dw++) {
                    for (let dz = -1; dz <= 1; dz++) {
                        for (let dy = -1; dy <= 1; dy++) {
                            for (let dx = -1; dx <= 1; dx++) {
                                if (dw === 0 && dz === 0 && dy === 0 && dx === 0) continue;

                                const nw = w + dw;
                                const nz = z + dz;
                                const ny = y + dy;
                                const nx = x + dx;

                                if (nw >= 0 && nw < SIZE && nz >= 0 && nz < SIZE && ny >= 0 && ny < SIZE && nx >= 0 && nx < SIZE) {
                                    if (board[nw][nz][ny][nx].isFlagged) {
                                        count++;
                                    }
                                }
                            }
                        }
                    }
                }
                return count;
            };

            const countUnrevealedUnflagged = (board, x, y, z, w) => {
                let count = 0;
                for (let dw = -1; dw <= 1; dw++) {
                    for (let dz = -1; dz <= 1; dz++) {
                        for (let dy = -1; dy <= 1; dy++) {
                            for (let dx = -1; dx <= 1; dx++) {
                                if (dw === 0 && dz === 0 && dy === 0 && dx === 0) continue;

                                const nw = w + dw;
                                const nz = z + dz;
                                const ny = y + dy;
                                const nx = x + dx;

                                if (nw >= 0 && nw < SIZE && nz >= 0 && nz < SIZE && ny >= 0 && ny < SIZE && nx >= 0 && nx < SIZE) {
                                    const adjacentCell = board[nw][nz][ny][nx];
                                    if (!adjacentCell.isRevealed && !adjacentCell.isFlagged) {
                                        count++;
                                    }
                                }
                            }
                        }
                    }
                }
                return count;
            };

            const handleMouseDown = (x, y, z, w) => {
                if (gameOver) return;
                setDragStart({ x, y, z, w });
                setDragCurrent({ x, y, z, w });
                setIsDragging(true);
            };

            const handleMouseUp = (x, y, z, w) => {
                if (!isDragging || !dragStart || gameOver) {
                    setDragStart(null);
                    setDragCurrent(null);
                    setIsDragging(false);
                    return;
                }

                // Check if we actually dragged to a different cell
                const isDifferentCell = dragStart.x !== x || dragStart.y !== y || dragStart.z !== z || dragStart.w !== w;

                if (isDifferentCell) {
                    justDraggedRef.current = true;
                    setTimeout(() => {
                        justDraggedRef.current = false;
                    }, 100);

                    const newBoard = board.map(arrW => arrW.map(arrZ => arrZ.map(arrY => arrY.map(cell => ({...cell})))));

                    // Calculate the bounds of the 4D hyperrectangle
                    const minX = Math.min(dragStart.x, x);
                    const maxX = Math.max(dragStart.x, x);
                    const minY = Math.min(dragStart.y, y);
                    const maxY = Math.max(dragStart.y, y);
                    const minZ = Math.min(dragStart.z, z);
                    const maxZ = Math.max(dragStart.z, z);
                    const minW = Math.min(dragStart.w, w);
                    const maxW = Math.max(dragStart.w, w);

                    // Reveal all unflagged cells in the hyperrectangle
                    let hitMine = false;
                    for (let tw = minW; tw <= maxW; tw++) {
                        for (let tz = minZ; tz <= maxZ; tz++) {
                            for (let ty = minY; ty <= maxY; ty++) {
                                for (let tx = minX; tx <= maxX; tx++) {
                                    const cell = newBoard[tw][tz][ty][tx];
                                    if (!cell.isFlagged && !cell.isRevealed) {
                                        revealCell(newBoard, tx, ty, tz, tw);
                                        if (cell.isMine) {
                                            hitMine = true;
                                        }
                                    }
                                }
                            }
                        }
                    }

                    if (hitMine) {
                        setGameOver(true);
                        revealAllMines(newBoard);
                    } else if (checkWinCondition(newBoard)) {
                        setWin(true);
                        setGameOver(true);
                    }

                    setBoard(newBoard);
                }

                setDragStart(null);
                setDragCurrent(null);
                setIsDragging(false);
            };

            const renderBoard = () => {
                if (!board.length) return null;

                return React.createElement('div', { className: 'grid-of-grids' },
                    Array.from({ length: SIZE }, (_, w) =>
                        Array.from({ length: SIZE }, (_, z) =>
                            React.createElement('div', { key: `${w}-${z}`, className: 'minesweeper-grid' },
                                board[w][z].map((row, y) =>
                                    row.map((cell, x) => {
                                        const isAdjacentToHovered = hoveredCell &&
                                            !cell.isRevealed &&
                                            !cell.isFlagged &&
                                            isAdjacent(x, y, z, w, hoveredCell.x, hoveredCell.y, hoveredCell.z, hoveredCell.w);

                                        // Check if cell is in drag selection
                                        const isInDragSelection = isDragging && dragStart && dragCurrent &&
                                            !cell.isFlagged &&
                                            !cell.isRevealed &&
                                            x >= Math.min(dragStart.x, dragCurrent.x) &&
                                            x <= Math.max(dragStart.x, dragCurrent.x) &&
                                            y >= Math.min(dragStart.y, dragCurrent.y) &&
                                            y <= Math.max(dragStart.y, dragCurrent.y) &&
                                            z >= Math.min(dragStart.z, dragCurrent.z) &&
                                            z <= Math.max(dragStart.z, dragCurrent.z) &&
                                            w >= Math.min(dragStart.w, dragCurrent.w) &&
                                            w <= Math.max(dragStart.w, dragCurrent.w);

                                        const adjacentFlagCount = countAdjacentFlags(board, x, y, z, w);
                                        const adjustedMineCount = cell.adjacentMines - adjacentFlagCount;
                                        const unrevealedUnflaggedCount = countUnrevealedUnflagged(board, x, y, z, w);

                                        let cellContent = '';
                                        if (cell.isFlagged) {
                                            cellContent = 'ðŸš©';
                                        } else if (cell.isRevealed && !cell.isMine) {
                                            // If there are unrevealed, unflagged cells, always show the count
                                            if (unrevealedUnflaggedCount > 0) {
                                                cellContent = adjustedMineCount;
                                            } else if (adjustedMineCount > 0) {
                                                // Only show if positive when all adjacent cells are revealed or flagged
                                                cellContent = adjustedMineCount;
                                            }
                                        }

                                        return React.createElement('div', {
                                            key: `${w}-${z}-${y}-${x}`,
                                            className: `cell ${cell.isRevealed ? 'revealed' : ''} ${cell.isMine && gameOver ? 'mine' : ''} ${cell.isFlagged ? 'flagged' : ''} ${isAdjacentToHovered ? 'adjacent' : ''} ${isInDragSelection ? 'drag-selected' : ''}`,
                                            onClick: () => {
                                                if (!justDraggedRef.current) {
                                                    handleCellClick(x, y, z, w);
                                                }
                                            },
                                            onContextMenu: (e) => handleFlag(e, x, y, z, w),
                                            onMouseDown: () => handleMouseDown(x, y, z, w),
                                            onMouseUp: () => handleMouseUp(x, y, z, w),
                                            onMouseEnter: () => {
                                                setHoveredCell({ x, y, z, w });
                                                if (isDragging) {
                                                    setDragCurrent({ x, y, z, w });
                                                }
                                            },
                                            onMouseLeave: () => setHoveredCell(null)
                                        }, cellContent);
                                    })
                                )
                            )
                        )
                    )
                );
            };

            const autoRevealAdjacent = (board, x, y, z, w) => {
                // Check all adjacent cells
                for (let dw = -1; dw <= 1; dw++) {
                    for (let dz = -1; dz <= 1; dz++) {
                        for (let dy = -1; dy <= 1; dy++) {
                            for (let dx = -1; dx <= 1; dx++) {
                                if (dw === 0 && dz === 0 && dy === 0 && dx === 0) continue;

                                const nw = w + dw;
                                const nz = z + dz;
                                const ny = y + dy;
                                const nx = x + dx;

                                if (nw >= 0 && nw < SIZE && nz >= 0 && nz < SIZE && ny >= 0 && ny < SIZE && nx >= 0 && nx < SIZE) {
                                    const adjacentCell = board[nw][nz][ny][nx];

                                    // If this adjacent cell is revealed and has adjusted count of 0
                                    if (adjacentCell.isRevealed && !adjacentCell.isMine) {
                                        const flagCount = countAdjacentFlags(board, nx, ny, nz, nw);
                                        const adjustedCount = adjacentCell.adjacentMines - flagCount;

                                        if (adjustedCount === 0) {
                                            // Reveal all unrevealed, unflagged neighbors
                                            for (let dw2 = -1; dw2 <= 1; dw2++) {
                                                for (let dz2 = -1; dz2 <= 1; dz2++) {
                                                    for (let dy2 = -1; dy2 <= 1; dy2++) {
                                                        for (let dx2 = -1; dx2 <= 1; dx2++) {
                                                            if (dw2 === 0 && dz2 === 0 && dy2 === 0 && dx2 === 0) continue;

                                                            const nnw = nw + dw2;
                                                            const nnz = nz + dz2;
                                                            const nny = ny + dy2;
                                                            const nnx = nx + dx2;

                                                            if (nnw >= 0 && nnw < SIZE && nnz >= 0 && nnz < SIZE && nny >= 0 && nny < SIZE && nnx >= 0 && nnx < SIZE) {
                                                                const neighborCell = board[nnw][nnz][nny][nnx];
                                                                if (!neighborCell.isRevealed && !neighborCell.isFlagged) {
                                                                    revealCell(board, nnx, nny, nnz, nnw);
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            };

            const handleFlag = (e, x, y, z, w) => {
                e.preventDefault();
                if (gameOver) return;

                const newBoard = board.map(arrW => arrW.map(arrZ => arrZ.map(arrY => arrY.map(cell => ({...cell})))));

                if (!newBoard[w][z][y][x].isRevealed) {
                    newBoard[w][z][y][x].isFlagged = !newBoard[w][z][y][x].isFlagged;

                    // Auto-reveal adjacent cells if any revealed neighbor now has adjusted count of 0
                    autoRevealAdjacent(newBoard, x, y, z, w);

                    // Check for mines that were revealed
                    let hitMine = false;
                    for (let tw = 0; tw < SIZE && !hitMine; tw++) {
                        for (let tz = 0; tz < SIZE && !hitMine; tz++) {
                            for (let ty = 0; ty < SIZE && !hitMine; ty++) {
                                for (let tx = 0; tx < SIZE && !hitMine; tx++) {
                                    if (newBoard[tw][tz][ty][tx].isMine && newBoard[tw][tz][ty][tx].isRevealed) {
                                        hitMine = true;
                                        setGameOver(true);
                                        revealAllMines(newBoard);
                                    }
                                }
                            }
                        }
                    }

                    // Check for win condition if no mine was hit
                    if (!hitMine && checkWinCondition(newBoard)) {
                        setWin(true);
                        setGameOver(true);
                    }
                }

                setBoard(newBoard);
            };

            const handleCellClick = (x, y, z, w) => {
                if (gameOver) {
                    // Reset the game and reveal the clicked cell
                    const newBoard = createBoard();
                    setGameOver(false);
                    setWin(false);

                    if (newBoard[w][z][y][x].isMine) {
                        setGameOver(true);
                        revealAllMines(newBoard);
                    } else {
                        revealCell(newBoard, x, y, z, w);
                        if (checkWinCondition(newBoard)) {
                            setWin(true);
                            setGameOver(true);
                        }
                    }
                    setBoard(newBoard);
                    return;
                }

                let newBoard = board.map(arrW => arrW.map(arrZ => arrZ.map(arrY => arrY.map(cell => ({...cell})))));

                if (newBoard[w][z][y][x].isMine) {
                    setGameOver(true);
                    revealAllMines(newBoard);
                } else {
                    revealCell(newBoard, x, y, z, w);
                    if (checkWinCondition(newBoard)) {
                        setWin(true);
                        setGameOver(true);
                    }
                }
                setBoard(newBoard);
            };

            const checkWinCondition = (board) => {
                for (let w = 0; w < SIZE; w++) {
                    for (let z = 0; z < SIZE; z++) {
                        for (let y = 0; y < SIZE; y++) {
                            for (let x = 0; x < SIZE; x++) {
                                const cell = board[w][z][y][x];
                                if (!cell.isMine && !cell.isRevealed) {
                                    return false;
                                }
                            }
                        }
                    }
                }
                return true;
            };

            const revealCell = (board, x, y, z, w) => {
                if (x < 0 || x >= SIZE || y < 0 || y >= SIZE || z < 0 || z >= SIZE || w < 0 || w >= SIZE) return;

                const cell = board[w][z][y][x];
                if (cell.isRevealed) return;

                cell.isRevealed = true;

                if (cell.adjacentMines === 0 && !cell.isMine) {
                    for (let dw = -1; dw <= 1; dw++) {
                        for (let dz = -1; dz <= 1; dz++) {
                            for (let dy = -1; dy <= 1; dy++) {
                                for (let dx = -1; dx <= 1; dx++) {
                                    if (dw === 0 && dz === 0 && dy === 0 && dx === 0) continue;
                                    revealCell(board, x + dx, y + dy, z + dz, w + dw);
                                }
                            }
                        }
                    }
                }
            };

            const revealAllMines = (board) => {
                for (let w = 0; w < SIZE; w++) {
                    for (let z = 0; z < SIZE; z++) {
                        for (let y = 0; y < SIZE; y++) {
                            for (let x = 0; x < SIZE; x++) {
                                if (board[w][z][y][x].isMine) {
                                    board[w][z][y][x].isRevealed = true;
                                }
                            }
                        }
                    }
                }
            };

            return React.createElement('div', { className: 'minesweeper-container' },
                React.createElement('h2', { className: 'section-title' }, '4D Minesweeper'),
                renderBoard(),
                win && React.createElement('div', { className: 'game-over-message' }, 'You Win!'),
                gameOver && !win && React.createElement('div', { className: 'game-over-message' }, 'Game Over'),
                React.createElement('button', {
                    className: 'btn btn-primary',
                    onClick: () => {
                        setGameOver(false);
                        setWin(false);
                        setBoard(createBoard());
                    }
                }, 'Reset')
            );
        };

        const MinesweeperSection = () => {
            return React.createElement('section', { id: 'minesweeper', className: 'minesweeper' },
                React.createElement('div', { className: 'container' },
                    React.createElement(Minesweeper4D)
                )
            );
        };

        const AppContent = () => {
            useEffect(() => {
                const smoothScroll = (e) => {
                    if (e.target.getAttribute('href')?.startsWith('#')) {
                        e.preventDefault();
                        const target = document.querySelector(e.target.getAttribute('href'));
                        if (target) {
                            target.scrollIntoView({ behavior: 'smooth', block: 'start' });
                        }
                    }
                };
                
                document.addEventListener('click', smoothScroll);
                
                const observer = new IntersectionObserver((entries) => {
                    entries.forEach(entry => {
                        if (entry.isIntersecting) {
                            entry.target.style.opacity = '1';
                            entry.target.style.transform = 'translateY(0)';
                        }
                    });
                }, {
                    threshold: 0.1,
                    rootMargin: '0px 0px -50px 0px'
                });
                
                const animatedElements = document.querySelectorAll('.skill-category, .project-card, .stat');
                animatedElements.forEach(el => {
                    el.style.opacity = '0';
                    el.style.transform = 'translateY(20px)';
                    el.style.transition = 'all 0.6s ease-out';
                    observer.observe(el);
                });
                
                const handleParallax = () => {
                    const scrolled = window.pageYOffset;
                    const parallaxElements = document.querySelectorAll('.floating-card');
                    parallaxElements.forEach(element => {
                        const speed = 0.5;
                        element.style.transform = `translateY(${scrolled * speed}px)`;
                    });
                };
                
                window.addEventListener('scroll', handleParallax);
                
                document.body.style.opacity = '0';
                document.body.style.transition = 'opacity 0.5s ease-in-out';
                setTimeout(() => {
                    document.body.style.opacity = '1';
                }, 100);
                
                return () => {
                    document.removeEventListener('click', smoothScroll);
                    window.removeEventListener('scroll', handleParallax);
                };
            }, []);
            
            return React.createElement('div', null,
                React.createElement(Navbar),
                React.createElement(HeroSection),
                React.createElement(AboutSection),
                React.createElement(ExperienceSection),
                React.createElement(ProjectsSection),
                React.createElement(MinesweeperSection),
                React.createElement(ContactSection),
                React.createElement(Footer)
            );
        };
        
        const App = () => {
            return React.createElement(ThemeProvider, null,
                React.createElement(AppContent)
            );
        };
        
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(React.createElement(App));
    </script>
</body>
</html>
